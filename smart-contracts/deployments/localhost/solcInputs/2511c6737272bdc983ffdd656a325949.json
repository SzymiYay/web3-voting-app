{
  "language": "Solidity",
  "sources": {
    "contracts/PollSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n// Errors\nerror PollSystem__PollLocked();\nerror PollSystem__PollEnded();\nerror PollSystem__AlreadyVoted();\nerror PollSystem__InvalidAnswersCount();\nerror PollSystem__InvalidOption();\nerror PollSystem__NotYetEnded();\nerror PollSystem__AlreadyLocked();\n\ncontract PollSystem {\n    // Types\n    enum State {\n        OPEN,\n        LOCKED\n    }\n\n    struct Poll {\n        string question;\n        string[] options;\n        uint64 possibleAnswers;\n        mapping(address => bool) hasVoted;\n        mapping(uint256 => uint256) votes;\n        uint256 endTime;\n        State state;\n    }\n\n    // State Variables\n    Poll[] public m_polls;\n\n    // Functions\n    function createPoll(\n        string memory question,\n        string[] memory options,\n        uint64 possibleAnswers,\n        uint256 duration\n    ) public {\n        Poll storage newPoll = m_polls.push();\n        newPoll.question = question;\n        newPoll.options = options;\n        newPoll.possibleAnswers = possibleAnswers;\n        newPoll.endTime = block.timestamp + duration;\n        newPoll.state = State.OPEN;\n    }\n\n    function vote(uint256 pollIndex, uint256[] memory chosenOptions) public {\n        Poll storage poll = m_polls[pollIndex];\n\n        if (poll.state != State.OPEN) revert PollSystem__PollLocked();\n        if (block.timestamp >= poll.endTime) revert PollSystem__PollEnded();\n        if (poll.hasVoted[msg.sender]) revert PollSystem__AlreadyVoted();\n        if (chosenOptions.length == 0 || chosenOptions.length > poll.possibleAnswers)\n            revert PollSystem__InvalidAnswersCount();\n\n        for (uint256 i = 0; i < chosenOptions.length; i++) {\n            uint256 option = chosenOptions[i];\n            if (option >= poll.options.length) revert PollSystem__InvalidOption();\n            poll.votes[option] += 1;\n        }\n        poll.hasVoted[msg.sender] = true;\n    }\n\n    function lockPoll(uint256 pollIndex) public {\n        Poll storage poll = m_polls[pollIndex];\n        if (poll.state == State.LOCKED) revert PollSystem__AlreadyLocked();\n        if (block.timestamp <= poll.endTime) revert PollSystem__NotYetEnded();\n        poll.state = State.LOCKED;\n    }\n\n    // Views\n    function getPollResults(uint256 pollIndex) public view returns (uint256[] memory) {\n        Poll storage poll = m_polls[pollIndex];\n        uint256[] memory results = new uint256[](poll.options.length);\n        for (uint256 i = 0; i < poll.options.length; i++) {\n            results[i] = poll.votes[i];\n        }\n\n        return results;\n    }\n\n    function getOpenPolls() public view returns (uint256[] memory) {\n        uint256 openPollsCount = 0;\n        for (uint256 i = 0; i < m_polls.length; i++) {\n            if (m_polls[i].state == State.OPEN) {\n                openPollsCount++;\n            }\n        }\n\n        uint256[] memory openPolls = new uint256[](openPollsCount);\n        uint256 index = 0;\n        for (uint256 i = 0; i < m_polls.length; i++) {\n            if (m_polls[i].state == State.OPEN) {\n                openPolls[index] = i;\n                index++;\n            }\n        }\n\n        return openPolls;\n    }\n\n    function hasVoted(uint256 pollIndex, address voter) public view returns (bool) {\n        return m_polls[pollIndex].hasVoted[voter];\n    }\n\n    function getPollState(uint256 pollIndex) public view returns (State) {\n        return m_polls[pollIndex].state;\n    }\n\n    function getPoll(uint256 pollIndex) public view returns (string memory, string[] memory, uint64, uint256, State) {\n        Poll storage poll = m_polls[pollIndex];\n        return (poll.question, poll.options, poll.possibleAnswers, poll.endTime, poll.state);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}